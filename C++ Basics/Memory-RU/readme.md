# Kinds of Memory

---

## 🔹 Типы памяти

- **Static memory**
- **Dynamic memory**
- **Automatic memory**

---

## 🧠 RAM — Random Access Memory

|	data	|	text	|	stack	|	heap	|


Когда запускаем прогрумму, то в **RAM** выделяется область в памяти —  **Data**, **Text**, **Stack**, **Heap**

---

## 1. 📦 Data Segment — Статичная память

Делится на две части:

- **Инициализированная часть** — это глобальные и статические переменные, которые были инициализированы  
	_Например:_  

	```cpp
	int a = 5;  
	int b = 0;
	```

- **Неинициализированная часть** — это глобальные и статические переменные, которые не были инициализированы  
	_Например:_ 

	```cpp
	int a;  
	int b;
	```

📌 Тут в основном хранятся **глобальные переменные** и другая информация, которая **живёт на протяжении всей жизни программы**.

---

## 2. ⚙️ Text Segment

- **Что это**: область, содержащая **исполняемый машинный код программы**. 0 и 1. 
- **Что туда попадает**: компилированные инструкции, т.е. то, что написано как `main()`, функции и т.д.

---

## 3. 🌀 Stack Segment — Автоматическая память

- **Что это**: область памяти, используемая для временного хранения **локальных переменных** и **вызова функций** (в том числе хранения return-адресов).
- **Как работает**: стек устроен по принципу **LIFO (Last In, First Out)**.  
  При каждом вызове функции создается **новый стек-фрейм**, а при выходе из функции он уничтожается.

-  🔸 Размер стека
Размер ограничен.

По умолчанию: фиксирован и равен 8 МБ

Может варьироваться от системы и версии

В основном это константа, заданная ОС

## ⚠️ Stack Overflow в разных языках

Язык	Сообщение об ошибке
**Python**	-	`RecursionError: maximum recursion depth exceeded`

**Java**	-	`java.lang.StackOverflowError`

**C#**		-	`System.StackOverflowException`

**JavaScript** -	`RangeError: Maximum call stack size exceeded`

**C++**		-	`Может быть Segmentation fault, иногда Aborted, зависит от ОС`

*Например:*

```cpp
#include <iostream>
void f(int x) {
	static int x = 0;
	std::cout << ++x << '\n';
	f(x);
}

int main() {
	f(0);
}
```
## 4. 🧱 Heap Segment - Динамическая память

- **Что это**: область памяти, используемая для хранения **данных**, которые могут изменяться во время выполнения программы. Runtime-память.
- **Как работает**: динамическая память используется для хранения данных, которые могут изменяться во время runtime программы. 
*Например:*

```cpp
int* p = new int;
delete p;
```
**Что тут происходит?**

Мы создаем `new int;` где `new` оператор, а `new int;` expresion. 

`p` это указатель на новый `int` который мы создали.

`delete p` мы удаляем память, которая была выделена под указатель. После этого, если обратится к `p` - будет ошибка

# Memory Leak
## Пример
```cpp
void f() {
    int* = new int(5);
}
```
Если не удалить память, то при выходе из функции ОС будет думать что эта переменная используется в коде и будет выделать память под неё.

**ВАЖНО**

удалить память нужно с помощью оператора `delete`

```cpp
void f() {
    int* p = new int(5);
    delete p;
}
```

Если потерять при выходу из функции указатель `p`, то память не будет удалена и ОС будет использовать её в коде. При долгом использовании память будет заполняться и в конечном итоге может занимать все память.

## Пример:

```cpp
#include <iostream>

void f() {
    int* p = new iint(5);
    std::cout << *p << ' ' << *p << std::endl;
    //delete p;
}

int main () {
    while (true)
        f();
}
```
Будет выделятся память каждый раз и заполнятся `5`, но не удалятся и запустив такую программу, можно наблюдать в Диспетчере задач или htop на **Linux** что память постоянно увеличивается.

## Пример:
```cpp
void f() {
	int* p = new int(5);
	int* pp = new int;
	delete p, pp;
}
```
удалится только `p`, а `pp` останется, потому что так работает С++. Оператор `delete` удаляет только первый	указатель, а второй не удаляется.

## Второй Пример:
```cpp
void f() {
	int* p = new int(5);
	int* pp = new int;
	delete (p, pp);
}
```
удалится только `pp`, а `p` останется в памяти, потому что так работает С++. 